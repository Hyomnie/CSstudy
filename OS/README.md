## Operating System

### Multi-process & Multi-thread
--------------------------------
* 프로세스: 실행중인 작업. code, data, heap, stack에 대한 독립적인 저장 공간을 가진다. <br>
* 멀티프로세스: 프로세스가 여러 개. 저장 공간을 공유하지 않으므로 안전성이 보장되지만 속도가 느리다. <br>`ex. google chrome browser` <br> 프로세스 간 통신은 ipc(Inter Process Communication)로 한다.<br>
* PCB(프로세스 제어 블록): 프로세스의 정보를 저장하는 자료구조. 스케줄 정보, 변수 등을 저장한다. <br>
* 스레드: 프로세스의 실행 단위. stack만 할당 받고 나머지 메모리는 공유한다. <br>
* 멀티스레드: 문맥 교환이 빠르다는 장점이 있지만 안정성이 낮다. (임계 영역을 통해 해결) `ex. 소켓 통신, 웹 서버`<br>
* 멀티스레드를 굳이 쓰는 이유? 시스템 콜이 감소해서 자원을 효율적으로 쓸 수 있다. 대신 동기화에 신경써야 한다.

### CPU scheduling
-------------------
##### 선점 스케줄링: Round Robin, SRT 등 / 비선점 스케줄링: FIFO, SJF 등
##### RR에서 time slice를 무한정 크게 하면 어떤 문제가 생기는가?
-결국 모든 프로세스가 완료될 때까지 기다리는 FIFO와 같아진다.
##### RR에서 time slice를 가장 작게 하면 어떤 문제가 생기는가?
-문맥 교환(context switching)이 너무 자주 일어나 오버헤드 된다.
##### 실제 시스템에선 어떤 스케줄링 기법을 사용하는가?
-RR과 multiple Queue를 같이 사용한다.
##### 선점 스케줄링 중 우선순위 발식을 사용할 때의 문제점과 해결방안은?
-우선순위가 낮은 프로세스는 무한정 대기하는 기아(starvation)문제가 생길 수 있고 이는 대기가 길어질수록 우선순위를 높여주는 aging 기법으로 해결할 수 있다.

### Deadlock
------------
프로세스가 요청한 자원을 얻지 못해 다음 단계를 실행하지 못하고 무한정 대기 상태에 머무는 것. <br>

* 상호배제: 프로세스들이 자원에 대한 배타적 통제권을 가짐.<br>
* 점유대기: 프로세스가 자원을 점유한 상태에서 다른 자원을 요청하고 대기함.<br>
* 비선점: 한 프로세스가 가진 자원을 다른 프로세스가 선점할 수 없음.<br>
* 순환대기: 프로세스들이 자원을 순환 형태로 가지고 요청하는 상태.<br><br>

데드락 해결 방법<br>
1. 예방: 4가지 조건 중 하나를 부정<br>
2. 회피: 은행원 알고리즘<br>
3. 탐지&회복<br>
4. 무시(실제로는 대부분의 경우 무시한다.)

![deadlock](https://user-images.githubusercontent.com/35550051/95063162-f5e63580-0738-11eb-8dc5-89d41e349744.png)<br>
대기 그래프. 사이클이 만들어지면 데드락이라고 탐지한다.

### Semaphore & Mutex
----------------------
* Semaphore: 리소스의 상태를 나타내는 간단한 카운터. 일반적으로 비교적 긴 시간을 확보하는 리소스에 대해 이용하게 되며, 유닉스 시스템의 프로그래밍에서 세마포어는 운영체제의 리소스를 경쟁적으로 사용하는 다중 프로세스에서 행동을 조정하거나 또는 동기화 시키는 기술이다. <br>
세마포어는 운영체제 또는 커널의 한 지정된 저장장치 내 값으로서, 각 프로세스는 이를 확인하고 변경할 수 있다. 확인되는 세마포어의 값에 따라, 그 프로세스가 즉시 자원을 사용할 수 있거나, 또는 이미 다른 프로세스에 의해 사용 중이라는 사실을 알게 되면 재시도하기 전에 일정 시간을 기다려야만 한다. 세마포어는 이진수(0 또는 1)를 사용하거나, 또는 추가적인 값을 가질 수도 있다. 세마포어를 사용하는 프로세스는 그 값을 확인하고, 자원을 사용하는 동안에는 그 값을 변경함으로써 다른 세마포어 사용자들이 기다리도록 해야 한다.<br>
* Mutex: Mutual Exclusion으로 상호배제라고도 한다. Critical Section을 가진 스레드들의 Runnig Time이 서로 겹치지 않게 각각 단독으로 실행되게 하는 기술. 다중 프로세스들의 공유 리소스에 대한 접근을 조율하기 위해 locking과 unlocking을 사용한다. 즉, 쉽게 말하면 뮤텍스 객체를 두 스레드가 동시에 사용할 수 없다는 의미이다.<br><br>
* 차이점
1. Semaphore는 Mutex가 될 수 있지만 Mutex는 Semaphore가 될 수 없다. (Mutex는 상태가 0, 1 두 개뿐인 binary Semaphore)
2. Semaphore는 소유할 수 없는 반면, Mutex는 소유가 가능하며 소유주가 이에 대한 책임을 진다. (Mutex의 경우 상태가 두 개뿐인 lock이므로 lock을 ‘가질’ 수 있다.)
3. Mutex의 경우 Mutex를 소유하고 있는 스레드가 이 Mutex를 해제할 수 있다. 하지만 Semaphore의 경우 이러한 Semaphore를 소유하지 않는 스레드가 Semaphore를 해제할 수 있다.

### Paging & Segmentation
--------------------------
* Paging: 하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 메모리 관리 방법. 외부 단편화는 없앨 수 있으나 내부 단편화가 있을 수 있다. 외부 단편화와 압축 작업을 해소하기 위해 생긴 방법론으로, 물리 메모리는 Frame이라는 고정 크기로 분리되어 있고, 논리 메모리는 페이지라 불리는 고정 크기의 블록으로 분리된다.<br>
* Segmentation: 논리 메모리와 물리 메모리를 같은 크기의 블록이 아닌, 서로 다른 크기의 논리적 단위인 세그먼트로 분할. 메모리를 쪼개서 적재하다 보면 외부 단편화가 생길 수 있다.<br>
* 페이지 교체 알고리즘: FIFO, LRU, LFU<br>
* 스레싱: 다중 프로그래밍 정도가 계속 늘어나다 보면 어느 순간부터 페이지 부재(page fault)가 과도하게 늘어나 실제 CPU 사용 시간보다 페이지를 교체하는 시간이 더 많아짐. 예방은 워킹 셋 사용.<br><br>
가상 머신: OS 위에 OS를 띄우는 것.<br>
컨테이너: OS 위에 프로세스(앱)를 띄우는 것. ex. 도커, 쿠버네티스

#### 참고자료
-------------
https://jwprogramming.tistory.com/13 <br>
https://gyoogle.dev/blog/ <br>
