## Operating System

#### 멀티프로세스 & 멀티스레드
* 프로세스: 실행중인 작업. code, data, heap, stack에 대한 독립적인 저장 공간을 가진다. <br>
* 멀티프로세스: 프로세스가 여러 개. 저장 공간을 공유하지 않으므로 안전성이 보장되지만 속도가 느리다. <br>`ex. google chrome browser` <br> 프로세스 간 통신은 ipc(Inter Process Communication)로 한다.<br>
* PCB(프로세스 제어 블록): 프로세스의 정보를 저장하는 자료구조. 스케줄 정보, 변수 등을 저장한다. <br>
* 스레드: 프로세스의 실행 단위. stack만 할당 받고 나머지 메모리는 공유한다. <br>
* 멀티스레드: 문맥 교환이 빠르다는 장점이 있지만 안정성이 낮다. (임계 영역을 통해 해결) `ex. 소켓 통신, 웹 서버`<br>
* 멀티스레드를 굳이 쓰는 이유? 시스템 콜이 감소해서 자원을 효율적으로 쓸 수 있다. 대신 동기화에 신경써야 한다.

#### 데드락
프로세스가 요청한 자원을 얻지 못해 다음 단계를 실행하지 못하고 무한정 대기 상태에 머무는 것. <br>

* 상호배제: 프로세스들이 자원에 대한 배타적 통제권을 가짐.<br>
* 점유대기: 프로세스가 자원을 점유한 상태에서 다른 자원을 요청하고 대기함.<br>
* 비선점: 한 프로세스가 가진 자원을 다른 프로세스가 선점할 수 없음.<br>
* 순환대기: 프로세스들이 자원을 순환 형태로 가지고 요청하는 상태.<br><br>

데드락 해결 방법<br>
1. 예방: 4가지 조건 중 하나를 부정<br>
2. 회피: 은행원 알고리즘<br>
3. 탐지&회복<br>
4. 무시(실제로는 대부분의 경우 무시한다.)
        
#### 페이징 & 세그먼테이션
* 페이징: 하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 메모리 관리 방법. 외부 단편화는 없앨 수 있으나 내부 단편화가 있을 수 있다. 외부 단편화와 압축 작업을 해소하기 위해 생긴 방법론으로, 물리 메모리는 Frame이라는 고정 크기로 분리되어 있고, 논리 메모리는 페이지라 불리는 고정 크기의 블록으로 분리된다.<br>
* 세그먼테이션: 논리 메모리와 물리 메모리를 같은 크기의 블록이 아닌, 서로 다른 크기의 논리적 단위인 세그먼트로 분할. 메모리를 쪼개서 적재하다 보면 외부 단편화가 생길 수 있다.<br>
* 페이지 교체 알고리즘: FIFO, LRU, LFU<br>
* 스레싱: 다중 프로그래밍 정도가 계속 늘어나다 보면 어느 순간부터 페이지 부재(page fault)가 과도하게 늘어나 실제 CPU 사용 시간보다 페이지를 교체하는 시간이 더 많아짐. 예방은 워킹 셋 사용.<br><br>
가상 머신: OS 위에 OS를 띄우는 것.<br>
컨테이너: OS 위에 프로세스(앱)를 띄우는 것. ex. 도커, 쿠버네티스
