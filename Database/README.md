### JOIN
### R DBMS & NOSQL
### 정규화 & 비정규화
### View
---------
#### view의 정의
- 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된 이름을 가지는 가상 테이블.
- 본래 데이터베이스 객체로 등록할 수 없는 SELECT 명령을, 객체로서 이름을 붙여 관리할 수 있도록 한 것이다.

#### view의 특징
1. 기본 테이블과 같은 형태의 구조를 사용한다.

#### view의 장점
2. 데이터의 논리적 독립성을 제공할 수 있다.
3. 필요한 데이터만 뷰로 정의해서 처리할 수 있기 때문에 관리가 용이하고 명령문이 간단해진다.
4. view를 통해서만 데이터에 접근하게 하면 view에 나타나지 않는 데이터를 안전하게 보호할 수 있다.

#### view의 단점
5. 독립적인 인덱스를 가질 수 없다.
6. view의 정의를 변경할 수 없다. ALTER VIEW문을 사용할 수 없다.
7. view로 구성된 내용에 대한 삽입, 삭제, 갱신, 연산에 제약이 따른다.

#### view 사용이유
- 서브쿼리 부분을 뷰로 대체하여 SELECT 명령을 간략하게 표현할 수 있다. 
- 복잡한 SELECT 명령을 DB에 등록해 두었다가 추후에 간단히 실행할 수 있다.
- 자주 사용하거나 복잡한 SELECT 명령을 view로 만들어 편리하게 사용할 수 있다.

#### view 정의문
```
CREATE VIEW 서울고객(성명, 전화번호)
AS SELECT 성명 전화번호
FROM 고객
WHERE 주소 = '서울시';
```
*WITH CHECK OPTION: 이 view에 대한 갱신이나 삽입 연산이 실행될 때 view의 정의 조건(WHERE문)이 위배될 경우 갱신이나 실행을 거부하도록 지정.<br>
*WITH READ ONLY: 기본 테이블의 어떤 컬럼에 대해서도 view를 통한 내용 수정을 불가능하게 만드는 옵션.

#### view 삭제문(view는 변경할 수 없으므로 필요한 경우 삭제 후 재생성한다.)
```
DROP VIEW 서울고객 RESTRICT;
```
*Restrict: view를 다른 곳에서 참조하고 있으면 삭제가 취소된다.<br>
*Cascade: view를 참조하는 다른 view나 제약 조건까지 모두 삭제된다.

### Index
---------
#### index의 정의
- 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어 두는 것
- 항상 정렬된 상태를 유지하기 때문에 원하는 값을 탐색하는데는 빠르지만 새로운 값을 추가하거나 삭제, 수정하는 경우에는 쿼리문 실행 속도가 느려진다. 

#### 왜 index 를 생성하는 데 b-tree 를 사용하는가? 데이터에 접근하는 시간복잡도가 O(1)인 hash table 이 더 효율적일 것 같은데? 
SELECT 질의의 조건에는 부호(<>) 연산도 포함이 된다. hash table 을 사용하게 된다면 등호(=) 연산이 아닌 부호 연산의 경우에 문제가 발생한다. 동등 연산(=)에 특화된 hashtable은 데이터베이스의 자료구조로 적합하지 않다.

#### SELECT 쿼리의 성능을 월등히 향상시키는 INDEX 항상 좋은 것일까? 쿼리문의 성능을 향상시킨다는데, 모든 컬럼에 INDEX 를 생성해두면 빨라지지 않을까? 
그렇지 않다. 우선, 첫 번째 이유는 INDEX 를 생성하게 되면 INSERT, DELETE, UPDATE 쿼리문을 실행할 때 별도의 과정이 추가적으로 발생한다.<br>
컬럼을 이루고 있는 데이터의 형식에 따라서 인덱스의 성능이 악영향을 미칠 수 있다는 것이다. 즉, 데이터의 형식에 따라 인덱스를 만들면 효율적이고 만들면 비효율적은 데이터의 형식이 존재한다는 것이다. 

### Transaction
----------------
#### 트랜잭션의 정의
하나의 논리적 작업 단위를 구성하는 일련의 연산들의 집합을 트랜잭션이라고 한다. 트랜잭션의 예로 계좌 간의 자금 이체가 많이 언급된다. 한 계좌에서 10만 원을 인출하여 다른 계좌로 10만 원 입금하는 이체 작업은 전체 작업이 정상적으로 완료되거나, 만약 정상적으로 처리될 수 없는 경우에는 아무 것도 실행되지 않은 처음 상태로 되돌려져야 한다.

#### ACID
* Atomicity(원자성): 트랜잭션의 모든 연산들이 정상적으로 수행 완료되거나 아니면 전혀 어떠한 연산도 수행되지 않은 상태를 보장해야 한다. atomicity는 쉽게 'all or nothing' 특성으로 설명된다.
* Consistency(일관성): 고립된 트랜잭션의 수행이 데이터베이스의 일관성을 보존해야 한다. 즉, 성공적으로 수행된 트랜잭션은 정당한 데이터들만을 데이터베이스에 반영해야 한다.
* Isolation(독립성): 여러 트랜잭션이 동시에 수행되더라도 각각의 트랜잭션은 다른 트랜잭션의 수행에 영향을 받지 않고 독립적으로 수행되어야 한다.
* Durability(지속성): 트랜잭션이 성공적으로 완료되어 커밋되고 나면, 해당 트랜잭션에 의한 모든 변경은 향후에 어떤 소프트웨어나 하드웨어 장애가 발생되더라도 보존되어야 한다.

#### Transaction Isolation Level
Read Uncommitted (레벨 0)
SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리지 않는 계층. 데이터베이스의 일관성을 유지하는 것이 불가능함
Read Committed (레벨 1)
SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리는 계층. Commit이 이루어진 트랜잭션만 조회 가능. SQL 서버가 Default로 사용하는 Isolation Level.
Repeatable Read (레벨 2)
트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 계층. 트랜잭션이 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장함.
Serializable (레벨 3)
완벽한 읽기 일관성 모드. 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 및 입력 불가능.

#### 낮은 단계 isolation level을 사용할 때 발생하는 문제
dirty read: 커밋되지 않은 수정중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생하는 현상.<br>
non-repeatable read<br>
phantom read<br>'

#### 참고자료
https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database#transaction <br>
https://gyoogle.dev/blog/computer-science/data-base/Transaction%20Isolation%20Level.html
